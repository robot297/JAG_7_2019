# Lab 7

**For all questions: if a specific method or variable name is given, use it.**
 
### Problem 1: Travel Wish List
 
A place object will need three private fields:
 *  A String name (for example, Hawaii)
 *  A String reason (a reason for visiting, for example, to go surfing)
 *  A Date created (when the Place object was created.

Date object information, example: https://github.com/claraj/Java2545Examples/blob/master/src/main/java/week7_first_classes/DateObjects.java

Create get and set methods for all three fields. Remember that
IntelliJ can generate these methods for you.

In this class, you'll need a constructor that takes two arguments, the
name, and the reason.

The constructor should instantiate a new Date, and use that to set the Date created.

Place objects need to be sorted by name.
You'll need to make Place implement Comparable to other Place objects. So, one Place can
be compared to another Place. This will allow a List of Place objects
to be sorted.

Add the `compareTo()` method that Comparable requires.

Place objects need to be printed. Create a `toString` method
that returns a String with all of the information about this place.
For the example data above, the String should be this EXACT form:

"Place to visit: Hawaii. Reason: to go surfing. Date created: Thu Oct 03 10:37:02 CDT 2019"

If the place name is "Rome" and the reason is "to visit the Colosseum" then
the String should be in this EXACT form:

"Place to visit: Rome. Reason: to visit the Colosseum. Date created: Thu Oct 03 10:42:19 CDT 2019"

The Date information will be whatever date's toString method returns. You don't need to do any
date formatting.
    

 
## Question 2 Support Ticket Manager 

This program is a prototype to manage IT support tickets for a company. Users would call or email a helpdesk to report computer problems, and this program keeps a record of all current problems. 

Ticket objects are used to store information about one problem.  A Ticket object needs to store a description of the problem, the Date the issue was reported, and the name of the user who reported it. 

The tickets are assigned a priority between 1-5.   
1 is the most urgent (example: all servers down)
5 is the least serious (example: missing mouse mat). 

Each Ticket will have a unique integer ID. This is generated by in the `TicketCounter` class. (We'll improve on this approach later in the semester when we cover databases.)

When a problem is fixed, the Ticket object is removed from the list of open tickets and added to a separate list of resolved tickets. A String describing the resolution is stored in the Ticket obhect, and the date the ticket was resolved. 

For this question, you'll add some features to the program. 

Run and test the program with some example support tickets.

### Problem 1: Review Design

To think about: 

* What is each class for? How are different responsibilities divided between the classes? 
* If `TicketStore` used permanent storage, like a database, instead of an in-memory LinkedList, would `TicketUI` or `Question_3_Support_Ticket_Manager` have to do anything differently?
* Make sure you understand the role of the TicketCounter class. How is it used to created new Ticket ID values? Why is it important that this 
* How does Ticket_Manager access a TicketStore object? Is it possible to create more than one TicketStore object? Why do you think this is? Hint: Google the "Singleton design pattern." 


### Problem 2: Validate ticket priorities

Add a check to `TicketUI.getNewTicketInfo()` method, to ensure that the priority entered for a new ticket is between 1 and 5, inclusive. 


### Problem 3: New menu options - Delete by Description, Search by Description

Add two new options to the menu: **Delete by Description**, and **Search by Description**. 
 Create two new static constants called `DELETE_BY_DESCRIPTION` and `SEARCH_BY_DESCRIPTION`. You'll need to add some more int constants; and modify the `configureMenuOptions` method; and modify the switch statement in `manage`.


### Problem 4: Implement search by description

The Search By Description feature will search your ticket list and return a new list of Tickets whose descriptions contain a certain String. For example, you might want to search for all tickets with the word “server” in the description.

The search should NOT be case sensitive.

You should not modify the description when you save tickets. So, the approach of saving all descriptions in lowercase or uppercase is not an acceptable solution for this problem.
 
Implement `TicketStore.searchByDescription` to search the list and return all matching tickets. 

If `TicketStore.searchByDescription` doesn't find any matches, return an empty list.
If `TicketStore.searchByDescription` is called with an empty string, or a null string, it should return an empty list.

Implement Question_2_Support_Ticket_Manager.menuOptionSearchByDescription. 
Use the `askUserQuestion` method in TicketUI to ask the user for the search String.
Use `TicketStore.searchByDescription` to search for matching tickets
Use the `displayTickets` method in TicketUI to display all matching tickets. 


### Problem 5: Store information about deleted/resolved tickets

In your program, when a ticket is deleted, it has been resolved in some way. Either a technician fixed the problem, or the user has figured out the solution, or it’s become a non-issue in some other way.

Modify the program so you can save information about deleted tickets.

Add two new private fields (variables) to the Ticket class.

Another Date; `resolvedDate`, the date the ticket was closed.
And, a String that documents why the ticket was closed – the fix or the resolution for the ticket. This String should be called `resolution`

Add public get and set methods for the two new resolved, and resolvedDate, fields. 

Modify the Ticket class toString method.  
If the ticket has not be resolved, return the current String.  
If the ticket has been resolved, the toString method should return a String containing the resolution, and date resolved.  

### Problem 6: Implement delete by ID

A ResolvedTicketStore class is provided for you. It stores resolved tickets in a list, and provides an `addTicket` method. 

Create a ResolvedTicketStore object in Ticket_Manager when the program starts. Note that you'll need to use the `ResolveTicketStore.getInstance()` method to access the singleton `resolvedTickets` object. 

Now, when you delete a Ticket, your `deleteTicketById` method should ask for the resolution. Store the resolution String, plus the current Date in the correct Ticket. Now, remove this Ticket from the ticketQueue list.

Finally, add the resolved ticket to your ResolvedTicketStore.


### Problem 7: Implement delete by description

Implement Delete by Description. 

In TicketManager's `deleteTicketByDescription` method,

- Ask user for search term e.g. "server"
- If there are matching tickets, use TicketUI to ask user which ticket ID to delete
- call deleteTicketById(ticketID) to delete the ticket with the ID given.
- else, use TicketUI to show user 'not found' message
 
